### Vue响应式源码
#### 数据劫持
* 获取到`Vue`实例化时传入`options`中的`data`
* 遍历`data`中的每一项，如果是对象的话，为对象的每一项设置`get/set`方法
* 如果是数组，会遍历数组的每一项，然后再监控它的每一项，并监控数组的索引
* 会改写数组原型上的push,pop,unshift,shift,reverse,splice,sort方法，因为这些方法会改变原数组
* 改写数组原型：先继承原生的原型方法，然后再调用原生的方法后，push,unshift,splice可以新增内容，对新增内容继续进行监控

#### 文本编译 1.0
#### 虚拟`DOM`

#### 依赖收集
* 首先会在属性的对象`get`方法中收集依赖，在对象属性的`get`方法通过`watcher`调用更新方法
* 数组的依赖需要单独收集，我们会在数组的身上绑一个`__ob__`方法
* 设置`get`方法时如果它的值是数组，要遍历数组的每一项，通过`__ob__`中的`dep`来收集依赖
* 当数组更新时(通过数组方法)，就会调用`__ob__.dep.notify`来通知渲染`watcher`来更新视图

Vue响应式存在的问题：
1. 为对象添加和删除属性不会具有响应式，可以通过Vue.set,Vue.delete
2. 通过数组的索引以及长度来修改不会具有响应式，需要调用数组的方法

### Watch
* 为每一个用户定义的watch设置用户定义的Watcher, `{user: true}`来标识
* 如果是自定义`watcher`，会获取`key`对应的`data`中的值，然后赋值给`this.value`，为最初的值，在不传`immediate`时是旧值
* 在用户取值的时候，对应属性的`get`方法执行，会收集用户自定义的`watcher`
* 当watch监听的属性更新时，首先会调用用户定义的`watcher`的更新方法，然后调用渲染`watcher`来更新视图更新方法
* 用户定义的`watcher`会在此获取此时更新后的最新的值，并调用传入的`handler(value,this.vlaue)`
* 之后调用渲染`watcher`的`update`方法来更新视图

### Computed
