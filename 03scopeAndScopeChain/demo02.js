// 作用域、堆栈内存、闭包

// 1.
// let x = 5;
// function fn (x) {
//   return function (y) {
//     console.log(y + (++x));
//   };
// }
// let f = fn(6); //
// f(7); // 14
// 函数执行的时候会形成一个全新的执行上下文(EC),并不会影响其它的该函数的执行上下文中执行的代码
// fn(8)(9); // 18  执行完成后会释放内存，函数内没有堆地址被外部使用
// 这里的作用域链查找时，会查找之前fn(6)执行时的执行上下文中的变量(作用域要从创建(开辟堆内存，并生成作用域)的位置去寻找)
// f(10)执行时会重新创建一个f函数执行的执行上下文环境
// f(10); // 18 f会一直占用着fn(6)返回值对应堆内存的地址，导致内存并不会被释放
// console.log(x); // 5

// 2.

let x = 5;
// 函数创建： 1. 创建堆内存 2. 生成作用域
function fn () {
  return function (y) {
    console.log(y + (++x));
  };
}

// 函数每次执行都会生成一个全新的执行上下文
// 函数执行： 1. 初始化作用域链  2. 实参赋值 3. 形参赋值 4. 执行代码
let f = fn(6);
f(7); // 7 + 6 =>  13
fn(8)(9); // 9 + 7 => 16

// f对应的存储地址创建于之前fn执行后的返回值，所以作用域链要在这里进行查找，所以会用到前一次fn执行时的上下文环境
f(10); // 10 + 8 => 18
console.log(x); // 8
