// for (var i = 0; i < 5; i++) {
//   setTimeout(() => {
//     console.log(i);
//   }, 10);
// }

// 通过闭包来进行解决
for (var i = 0; i < 5; i++) {
  // 每一次函数执行都会形成一个全新的执行上下文，每个执行上下文中的代码执行各自独立
  // 函数定义：1. fn.[[scope]] = [VO(G)]  2. fn === AAAFFF111
  // 函数执行：
  // 1. 初始化作用域链：fn.scopeChain = [AO(fn),VO(G)]
  // 2. 初始化实参:arguments
  // 3. 形参赋值：i = 0(以第一次为例)
  // 4. 变量声明提升(函数和变量声明提升时互不影响)
  // 5. 代码执行
  // 在代码执行时，传入了10秒后执行函数的堆地址AAAFFF222
  // 在这10秒后，传入的匿名函数会在setTimeout中执行，而在此之前，它的地址会在setTimeout形参赋值时所引用
  // 而setTimeout是全局变量对象(VO(G))window中的方法，所以会被全局变量对象中的变量所占用，形成闭包，
  // 导致执行上下文不会出栈即不会销毁：
  // 即fn中的匿名函数被外部上下文中的`setTimeout`执行时所形成的执行上下文中的变量所占用，所以fn不会被立即销毁，从而形成闭包
  // 在匿名函数执行时，用到i的值会从作用域中进行查找，由于每个上下文之间不会相互影响，所以获取的i值都是传入时的值

  // 闭包的机制：保存(值可以保存下来，一直供其内的内容访问)/保护(防止被外部的变量所影响)

  // 缺点：每次执行都会生成对应的执行上下文，从而占据执行上下文栈中较多的空间
  (function fn (i) {
    setTimeout(() => {
      console.log(i);
    }, 10);
  }(i));
}

// 使用let
// let 存在块级作用域
// 底层实现类似于闭包
{
  // 父块作用域
  let i = 0;
  // 第一次循环
  {
    // 子块作用域,将i传进来，并进行形参赋值(相当于有形参i的函数自执行)
    let i = 0;
    setTimeout(() => console.log(i), 10);
  }
  i++;
  // 第二次循环
  {
    let i = 1;
    setTimeout(() => console.log(i), 10);
  }
  // ...
}
for (let i = 0; i < 5; i++) {
  console.log(i);
}
