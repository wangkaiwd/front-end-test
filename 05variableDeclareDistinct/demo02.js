// for (var i = 0; i < 5; i++) {
//   setTimeout(() => {
//     console.log(i);
//   }, 10);
// }

// 通过闭包来进行解决
for (var i = 0; i < 5; i++) {
  // 每一次函数执行都会形成一个全新的执行上下文，每个执行上下文中的代码执行各自独立
  // 函数定义：1. fn.[[scope]] = [VO(G)]  2. fn === AAAFFF111
  // 函数执行：
  // 1. 初始化作用域链：fn.scopeChain = [AO(fn),VO(G)]
  // 2. 初始化实参:arguments
  // 3. 形参赋值：i = 0(以第一次为例)
  // 4. 变量声明提升(函数和变量声明提升时互不影响)
  // 5. 代码执行
  // 在代码执行时，传入了10秒后执行函数的堆地址AAAFFF222
  // 在这10秒后，传入的匿名函数会在setTimeout中执行，而在此之前，它的地址会在setTimeout形参赋值时所引用
  // 而setTimeout是全局变量对象(VO(G))window中的方法，所以会被全局变量对象中的变量所占用，形成闭包，
  // 导致执行上下文不会出栈即不会销毁：
  // 即fn中的匿名函数被外部上下文中的`setTimeout`执行时所形成的执行上下文中的变量所占用，所以fn不会被立即销毁，从而形成闭包
  // 在匿名函数执行时，用到i的值会从作用域中进行查找，由于每个上下文之间不会相互影响，所以获取的i值都是传入时的值
  ~function fn (i) {
    setTimeout(() => {
      console.log(i);
    }, 10);
  }(i);
}
